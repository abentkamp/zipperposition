#use "topfind";;
#require "unix";;
#require "zarith";;
#require "containers";;
#require "containers.data";;
#require "sequence";;
#require "gen";;
#require "mtime.clock.os";;
#directory "_build/src/"
#directory "_build/src/core";;
#directory "_build/src/prover";;
#directory "_build/src/parsers";;
#directory "_build/src/meta/";;
#directory "_build/src/arbitrary/";;
#directory "_build/tests/";;

print_endline "load base lib....";;
#load "logtk.cma";;
open Logtk;;
module ST = InnerTerm;;
module T = Term;;
module PT = STerm;;
let (~<) = ID.make;;
#install_printer ID.pp;;
#install_printer Type.pp;;
#install_printer FOTerm.pp;;
#install_printer STerm.pp;;
#install_printer TypedSTerm.pp;;
#install_printer Substs.pp;;
#install_printer Signature.pp;;
#install_printer ParseLocation.pp;;
#install_printer Precedence.pp;;
#install_printer Ordering.pp;;
#install_printer Position.pp;;
#install_printer Ordinal.pp;;

(* optional part: parser *)
print_endline "load parser lib...";;
#require "tip_parser";;
#load "logtk_parsers.cma";;
open Logtk_parsers;;
#install_printer UntypedAST.pp_statement;;
let pterm s =
    let t = Parse_zf.parse_term Lex_zf.token (Lexing.from_string s) in
    let tyctx = TypeInference.Ctx.create () in
    let t = TypeInference.infer_exn tyctx t in
    TypeInference.Ctx.exit_scope tyctx;
    t
;;

(* optional part: arbitrary *)
#require "qcheck";;
#load "logtk_arbitrary.cma";;

print_endline "load prover lib...";;
#load "libzipperposition_prover.cma";;
module M = Monome;;
module MF = Monome.Focus;;
#install_printer FOTerm.pp;;
#install_printer Literal.pp;;
#install_printer Clause.pp;;
#install_printer STerm.pp;;
#install_printer Substs.FO.pp;;
#install_printer Proof.pp;;
#install_printer Signature.pp;;
#install_printer Type.pp;;
#install_printer Monome.pp;;
let pterm_tptp s = Parse_tptp.parse_term Lex_tptp.token (Lexing.from_string s);;
let pform_tptp s = Parse_tptp.parse_formula Lex_tptp.token (Lexing.from_string s);;
Printf.printf "finished loading\n";;
